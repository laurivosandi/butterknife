#!/bin/sh

# This script parses following arguments from /proc/cmdline:
#   - bk_url=https://mgmt.koodur.com/api
#   - bk_template=your-template
#   - bk_version=snap9
#   - bk_domain=32kk.lan

# TODO: Make sure fdisk from busybox is NOT used, it's counting sectors incorrectly (?!)
# Dependencies: fdisk btrfs find dialog ntfs-3g ntfsprogs parted

# TODO: Check connectivity with API server
POOL_MOUNTPOINT=/var/butterknife/pool
TARGET_MOUNTPOINT=/mnt/target

AGENT="Butterknife-Provisioning-Image/0.1"
URL_LOCAL=http://butterknife/api


#######################################
### Check for presence of utilities ###
#######################################
for util in btrfs jq fdisk find ntfsresize udp-sender udp-receiver ntpdate curl ms-sys mktemp test true sort uniq; do
    if [ -z "$(which $util)" ]; then
        dialog --msgbox "Butterknife was unable to locate $util,\
            are you sure the provisioning image was compiled properly?" 0 0
        exit 253
    else
        echo "Found $util..."
    fi
done

set -x # Don't echo
set -e # Bail on error

#######################################
### Transfer method selection phase ###
#######################################

TRANSFER_METHOD=$(dialog --menu "Select transfer method" 0 0 0 \
    http "HTTP-only" \
    multicast "Multicast receive" \
    tee "Multicast via HTTP and write" \
    proxy "Only proxy HTTP to multicast" 2>&1 >$(tty))


##################################
### Harddisk preparation phase ###
##################################

case $TRANSFER_METHOD in
    http|multicast|tee)
        #############################
        ### Target disk selection ###
        #############################

        if [ -z "$(ls /sys/class/block/)" ]; then
            dialog --msgbox "Butterknife was unable to detect any harddisks,\
                are you sure harddisk is connected and we have drivers for it?" 0 0
            exit 255
        fi

        for disk in /sys/class/block/*; do
            if [ -d $disk/device ]; then
                slug=$(basename $disk)
                sector_count=$(cat $disk/size)
                sector_size=$(cat $disk/queue/hw_sector_size)
                # Hack around these dumbass cardreaders
                
                if [ "$sector_count" == "0" ]; then
                    continue
                fi
                size=$(expr $sector_count / 1000000 \* $sector_size / 1000 || true)G

                echo "$slug \"$(cat $disk/device/model | xargs) ($size)\"";
            fi
        done > /tmp/disks

        dialog \
            --menu "Target disk" 0 0 0 \
            --file /tmp/disks \
            2> /tmp/selected_disk

        DISK_SLUG=$(cat /tmp/selected_disk)
        DISK=/dev/$DISK_SLUG

        PARTITIONING_METHOD=$(dialog --menu "Partitioning $DISK" 0 0 0 \
            receive         "Receive into existing btrfs filesystem" \
            unpartitioned   "Use unpartitioned area" \
            resize          "Resize last partition" \
            reformat        "Reformat partition" \
            purge           "Overwrite whole disk" \
            2>&1 >$(tty))

        # TODO: deploy          "Deploy received template" \
        # TODO: postinstall     "Run postinstall scripts (reinstall GRUB)" \

        # TODO: EFI way is not currently covered!
        case $PARTITIONING_METHOD in
            unpartitioned)
                clear 
                echo "Attempting to create new partition in unpartitioned space"
                echo -e "n\np\n\n\n\nw" | fdisk $DISK
            ;;
            resize)
                clear
                NTFS_PARTITION=$(ls $DISK? | tail -n 1)
                # TODO: Assert last one is NTFS
                # TODO: Suggested size heuristics
                MINSIZE=$(ntfsresize $NTFS_PARTITION -m | grep Minsize | cut -d ':' -f 2)
                SUGGESTED=${MINSIZE}M
                SIZE=$(dialog --inputbox "Enter new filesystem size of at least ${MINSIZE}M" 0 0 $SUGGESTED 2>&1 >$(tty))
                ntfsresize -s $SIZE $NTFS_PARTITION
                echo -e "d\n\nw" | fdisk $DISK # Remove last partition
                echo -e "n\np\n\n\n+$SIZE\nt\n\n7\nw" | fdisk $DISK # Re-create NTFS
                echo -e "n\np\n\n\n\nw" | fdisk $DISK # Create partition for btrfs
            ;;
            purge)
                clear
                echo "Purging whole disk"
                echo -e "o\nn\np\n\n\n\nw" | fdisk $DISK
            ;;
            reformat|receive)
                # NOOP
            ;;
            *)
                echo "Invalid partitioning method $PARTITIONING_METHOD"
                exit 255
            ;;
        esac


        ############################################
        ### Target partition determination phase ###
        ############################################
        case $PARTITIONING_METHOD in
            reformat|receive)
                # Dialog to select partition for reformat or receive
                for partition in $DISK?; do
                    partition_slug=$(echo $partition | cut -d "/" -f 3)
                    sector_count=$(cat /sys/block/$DISK_SLUG/$partition_slug/size)
                    sector_size=$(cat /sys/block/$DISK_SLUG/queue/hw_sector_size)
                    size=$(expr $sector_count / 1000000 \* $sector_size / 1000 || true)G
                    if [ $size == "0G" ]; then
                        size=$(expr $sector_count / 1000 \* $sector_size / 1000 || true)M
                    fi
                    echo "$partition \"$size\"";
                done > /tmp/partitions

                PARTITION=$(dialog \
                    --menu "Target partition" 0 0 0 \
                    --file /tmp/partitions \
                    2>&1 >$(tty))
            ;;
            unpartitioned|resize|purge)
                # Assume last partition
                PARTITION=$(ls $DISK? | tail -n 1)
            ;;
            *)
                echo "Invalid partitioning method $PARTITIONING_METHOD"
                exit 255
            ;;
        esac

        PARTITION_SLUG=$(echo $PARTITION | cut -d "/" -f 3)


        ########################################
        ### Target filesystem creation phase ###
        ########################################
        case $PARTITIONING_METHOD in
            purge|reformat|unpartitioned|resize) 
                clear
                echo "Creating clean btrfs filesystem on $PARTITON"
                mkfs.btrfs -f $PARTITION
            ;;
        esac

        # Attempt to mount target directory
        mkdir -p $POOL_MOUNTPOINT
        mount $PARTITION $POOL_MOUNTPOINT -o subvol=/        
        if [ $? -ne 0 ]; then
            dialog --msgbox "Mounting $PARTITION at $POOL_MOUNTPOINT failed, are you sure kernel has btrfs support built-in?" 0 0
            exit 255
        fi
        
        ################
        ### Clean up ###
        ################

        for subvol in $(ls $POOL_MOUNTPOINT |  (grep "^@template:" || true)); do
            set +e
            touch $POOL_MOUNTPOINT/$subvol/.test
            if [ $? -eq 0 ]; then
                set -e
                btrfs subvol delete $POOL_MOUNTPOINT/$subvol
            fi
            set -e
        done
    ;;
    *)
        PARTITIONING_METHOD="pass"
    ;;
esac

##############################
### Determine architecture ###
##############################

bk_arch=$(uname -m | sed 's/^i.86$/x86/')

case $TRANSFER_METHOD in
    http|tee|proxy)
        ##############################
        ### Server selection phase ###
        ##############################
        if [ -z $bk_url ]; then

            bk_url=$(dialog --menu "Select server" 0 0 0 \
                $URL_LOCAL                       "Use local or manually enter" \
                https://butterknife.koodur.com/api/   "Koodur LLC" 2>&1 >$(tty))
                
            if [ "$bk_url" == $URL_LOCAL ]; then
                bk_url=$(dialog --inputbox "Use local instance or customize URL" \
                    0 0 $URL_LOCAL 2>&1 >$(tty))
            fi
        fi


        ################################
        ### Template selection phase ###
        ################################

        if [ -z $bk_template ]; then
            # Fetch template list
            curl -A $AGENT -s $bk_url/template/ \
                | jq '.templates[] | .namespace + "." + .identifier + " \"" + .description + "\""' -r \
                > /tmp/available_templates

            bk_template=$(dialog \
                --menu "Select template to deploy" 0 0 0 \
                --file /tmp/available_templates \
                2>&1 >$(tty))

        fi

        ###############################
        ### Version selection phase ###
        ###############################
        if [ -z $bk_version ]; then
            # Fetch version list
            curl -A $AGENT -s $bk_url/template/$bk_template/arch/$bk_arch/version/ \
                > /tmp/available_versions.json        

            cat /tmp/available_versions.json \
                | jq '.versions[] | .identifier + " \"" + .comment + "\""' -r \
                | head -n 100 \
                > /tmp/available_versions

            bk_version=$(dialog \
                --menu "Select version to deploy" 0 0 0 \
                --file /tmp/available_versions \
                2>&1 >$(tty))
        fi

        bk_template_subvol="@template:$bk_template:$bk_arch:$bk_version"

        clear

        #####################################
        ### Stream URL construction phase ###
        #####################################

        # Build btrfs-stream URL
        STREAM="$bk_url/template/$bk_template/arch/$bk_arch/version/$bk_version/stream?src="
    ;;
esac


##############################################
### Allow differential versions using HTTP ###
##############################################

case $TRANSFER_METHOD in
    http)
        # Determine differential version parents
        cat /tmp/available_versions.json | jq -r '.versions[] .identifier' > /tmp/available_version_names
        ls $POOL_MOUNTPOINT | (grep "^@template:$bk_template:$bk_arch:" || true) | cut -d ":" -f 4 > /tmp/local_version_names
        cat /tmp/local_version_names /tmp/available_version_names > /tmp/merged_version_names

        PARENTS=$(cat /tmp/merged_version_names | sort | grep -v $bk_version | uniq -d)

        for parent in $PARENTS; do
            STREAM="$STREAM$parent,"
        done

        echo "Final URL is $STREAM"
    ;;
esac


######################
### Transfer phase ###
######################

case $TRANSFER_METHOD in
    multicast)
        ls $POOL_MOUNTPOINT | (grep "^@template:" || true) > /tmp/local_templates
        udp-receiver --nokbd \
            | btrfs receive $POOL_MOUNTPOINT/
        # Heuristics to determine name of received snapshot
        ls $POOL_MOUNTPOINT | (grep "^@template:" || true) > /tmp/new_templates
        bk_template_subvol=$(cat /tmp/local_templates /tmp/new_templates | sort | uniq -u)
        # TODO: Break here if we got garbage
        bk_template=$(echo $bk_template_subvol | cut -d ":" -f 2)
        bk_arch=$(echo $bk_template_subvol | cut -d ":" -f 3)
        bk_version=$(echo $bk_template_subvol | cut -d ":" -f 4)
    ;;
    http)
        curl --compressed -A $AGENT $STREAM \
            | btrfs receive $POOL_MOUNTPOINT/
    ;;
    tee)
        dialog --msgbox "Press enter once all the other machines are ready to receive" 0 0
        mkfifo /tmp/multicast_stream /tmp/local_stream
        cat /tmp/local_stream | btrfs receive $POOL_MOUNTPOINT/ &
        sleep 1
        udp-sender --nokbd --no-progress --min-receivers 1 --min-wait 5 /tmp/multicast_stream &
        sleep 1
        curl --compressed -A $AGENT  -s $STREAM | tee /tmp/multicast_stream > /tmp/local_stream
        sleep 2
        # TODO: Ensure btrfs receive has finished
    ;;
    proxy)
        dialog --msgbox "Press enter once all the other machines are ready to receive" 0 0
        curl --compressed -A $AGENT -s $STREAM \
            | udp-sender --nokbd --min-receivers 1 --min-wait 5
    ;;
esac

sync

case $PARTITIONING_METHOD in
    pass)
        echo "Skipping template deployment"
    ;;
    *)
        #################################
        ### Template deployment phase ###
        #################################
        
        bk_deploy_subvol="@root:$bk_template:$bk_arch:$bk_version"
        btrfs subvolume snapshot $POOL_MOUNTPOINT/$bk_template_subvol $POOL_MOUNTPOINT/$bk_deploy_subvol
        
        # Symlink @root:active to current deployment subvol
        rm -f $POOL_MOUNTPOINT/@root:active
        ln -s $bk_deploy_subvol $POOL_MOUNTPOINT/@root:active
        

        ###############################
        ### Run post-deploy scripts ###
        ###############################

        # Mount deployment subvolume at target directory
        mkdir -p $TARGET_MOUNTPOINT
        mount $PARTITION $TARGET_MOUNTPOINT -o subvol=$bk_deploy_subvol

        # Mount pool also for chroot
        mkdir -p $TARGET_MOUNTPOINT$POOL_MOUNTPOINT
        mount $PARTITION $TARGET_MOUNTPOINT$POOL_MOUNTPOINT -o subvol=/

        # Mount stuff for chroot
        mount --bind /dev/ $TARGET_MOUNTPOINT/dev/
        mount --bind /sys/ $TARGET_MOUNTPOINT/sys/
        mount --bind /proc/ $TARGET_MOUNTPOINT/proc/
        mount none $TARGET_MOUNTPOINT/tmp/ -t tmpfs

        # Export variables for postinstall scripts
        export BUTTERKNIFE_DOMAIN=$bk_domain
        export BUTTERKNIFE_TEMPLATE_SUBVOL=$bk_template_subvol
        export BUTTERKNIFE_DEPLOY_SUBVOL=$bk_deploy_subvol
        export BUTTERKNIFE_PARTITION=$PARTITION
        export BUTTERKNIFE_DISK=$DISK
        export BUTTERKNIFE_POOL_MOUNTPOINT=$POOL_MOUNTPOINT
        export BUTTERKNIFE_PARTITIONING_METHOD=$PARTITIONING_METHOD # One of purge,reformat,unpartitionied,resize,receive
        export BUTTERKNIFE_TRANSFER_METHOD=$TRANSFER_METHOD # One of multicast,http,tee
        export BUTTERKNIFE_POOL_UUID=$(blkid -s UUID -o value $PARTITION)
        
        # Copy DNS config
        cat /etc/resolv.conf > $TARGET_MOUNTPOINT/etc/resolv.conf
        
        # Export sensible PATH
        export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

        # Run postinstall scripts, presumably in sorted order
        chroot $TARGET_MOUNTPOINT butterknife-postdeploy

        # Be forgiving from now on
        set +e

        # Unmount directories
        umount $TARGET_MOUNTPOINT$POOL_MOUNTPOINT
        umount $TARGET_MOUNTPOINT/dev
        umount $TARGET_MOUNTPOINT/sys
        umount $TARGET_MOUNTPOINT/proc
        umount $TARGET_MOUNTPOINT/tmp
        umount $TARGET_MOUNTPOINT
        umount $POOL_MOUNTPOINT

        echo "Flushing buffers"
        sync
        sleep 1
        echo "Rebooting machine"
        reboot -f
    ;;
esac

