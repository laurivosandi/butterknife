#!/usr/bin/python3
import os
import click
from urllib.parse import urlparse
import json
import urllib.request
import configparser
import subprocess

class Template(object):
    def __init__(self, address):
        self.o = urlparse(address)
        subvol = os.path.basename(self.o.path)
        _, fqn, self.architecture, self.version = subvol.split(":")
        self.namespace, self.identifier = fqn.rsplit(".", 1)
        assert self.version.startswith("snap")
        self.numeric_version = int(self.version[4:])

    def __repr__(self):
        return str(self)

    def __str__(self):
        return "@template:%s.%s:%s:%s" % (self.namespace, self.identifier, self.architecture, self.version)

    def __eq__(self, other):
        return repr(self) == repr(other)

    def __gt__(self, other):
        return self.numeric_version > other.numeric_version

    def __gt__(self, other):
        return self.numeric_version > other.numeric_version

    def __hash__(self):
        return hash(repr(self))
        
        
class LocalPool(object):
    def __init__(self, path="/var/butterknife/pool"):
        self.path = os.path.abspath(path)
        
    def __str__(self):
        return "file://%s" % self.path
        
    def template_list(self, f=None):
        templates = {}
        for entry in self.subvol_list():
            if f and not f.check(entry):
                continue
            category, fqn, arch, version = entry.split(":")
            namespace, identifier = fqn.rsplit(".", 1)
            templates[(namespace, identifier)] = templates.get((namespace, identifier), set()).union({arch})
            
        for (namespace, identifier), architectures in templates.items():
            yield namespace, identifier, tuple(architectures)

    def subvol_list(self):
        return os.listdir(self.path)
        
    def receive(self, fh, subvol, parent=None):
        cmd = "btrfs", "receive", os.path.join(self.path)
        if parent_subvol:
            cmd += "-p", os.path.join(self.path, str(parent_subvol))
        return subprocess.Popen(cmd, stdin=fh)

    def send(self, subvol, parent=None):
        cmd = "btrfs", "send", os.path.join(self.path, str(subvol))
        if parent_subvol:
            cmd += "-p", os.path.join(self.path, str(parent_subvol))
        if os.getuid() > 0:
            cmd = ("sudo",) + cmd
        return subprocess.Popen(cmd, stdout=subprocess.PIPE, close_fds=True)

class SecureShellPool(object):
    def __init__(self, hostname, port=None, user=None, path="/var/butterknife/pool"):
        self.hostname = hostname
        self.port = port 
        self.path = path
        self.user = user
        
    def __str__(self):
        url = "ssh://"
        if self.username:
            url += "%s@" % self.username
        url += self.hostname
        if self.port:
            url += ":%d" % self.port
        if self.path != "/var/butterknife/pool/":
            url += self.path
        return url
        
    def subvol_list(self):
        return subprocess.check_output(self.prefix() + ("ls", self.path)).decode("utf-8").split("\n")
        
    def prefix(self):
        cmd = "ssh",
        if self.port:
            cmd += "-p", self.port
        if self.user:
            cmd += self.user + "@"
        return cmd + self.hostname

    def receive(self, fh, subvol, parent=None):
        cmd = self.prefix() + "btrfs", "receive", os.path.join(self.path)
        if parent_subvol:
            cmd += "-p", os.path.join(self.path, str(parent_subvol))
        return subprocess.Popen(cmd, stdin=fh)

    def send(self, subvol, parent=None):
        cmd = self.prefix() + "btrfs", "send", os.path.join(self.path, str(subvol))
        if parent_subvol:
            cmd += "-p", os.path.join(self.path, str(parent_subvol))
        return subprocess.Popen(cmd, stdout=subprocess.PIPE, close_fds=True)
        

class Pool(object):
    def __init__(self, address):
        o = urlparse(address)
        assert o.scheme in ("http", "https", "ssh", "file"), "Invalid transport %s" % o.scheme
        if o.scheme == "file":
            assert not o.netloc, "Username, hostname or port not supported for file:// transport"

        assert not o.password
        assert not o.fragment
        assert not o.query

        self.scheme = o.scheme
        self.port = o.port
        self.username = o.username
        self.hostname = o.hostname

        if o.path:
            self.path = o.path
        else:
            self.path = "/var/butterknife/pool"
        if not self.path.endswith("/"):
            self.path += "/"

    def __str__(self):
        url = ""
        if self.scheme != "file":
            url += self.scheme + "://"
        if self.username:
            url += "%s@" % self.username
        if self.hostname:
            url += self.hostname
        if self.port:
            url += ":%d" % self.port
        if self.path != "/var/butterknife/pool/":
            url += self.path
        elif self.scheme != "file":
            url += "/"
        return url

    def command_receive(self, parent_subvol=None):
        cmd = "btrfs", "receive", self.path

        if self.scheme == "file":
            prefix = ()
        elif self.scheme == "ssh":
            prefix = "ssh", (self.username + "@" if self.username else "") + self.hostname,
            if self.port:
                prefix += "-p", self.port
        else:
            raise Exception("Unable to receive to transport %s" % self.scheme)

        if parent_subvol:
            cmd += "-p", os.path.join(self.path, str(parent_subvol))
        return prefix + cmd

    def command_send(self, subvol, parent_subvol=None):
        if self.scheme == "file":
            cmd = "btrfs", "send", os.path.join(self.path, str(subvol))
        elif self.scheme == "ssh":
            cmd = "ssh", (self.username + "@" if self.username else "") + self.hostname,
            if self.port:
                cmd = cmd + ("-p", self.port)
            cmd += "btrfs", "send", os.path.join(self.path, str(subvol))
        else:
            raise Exception("Unable to receive to transport %s" % self.scheme)

        if parent_subvol:
            cmd += "-p", os.path.join(self.path, str(parent_subvol))
        return cmd
        
    def filter_names(self, **kwargs):
        for entry in self.filter_subvols(**kwargs):
            yield entry.namespace, entry.identifier

    def filter_templates(self, **kwargs):
        for entry in self.filter_subvols(**kwargs):
            yield entry.namespace, entry.identifier, entry.architecture

    def filter_subvols(self, category="@template", namespace="*", identifier="*", architecture="*", version="*"):
        for entry in self.list_subvols():
            if namespace != "*" and entry.namespace != namespace:
                continue
            if identifier != "*" and entry.identifier != identifier:
                continue
            if architecture != "*" and entry.architecture != architecture:
                continue
            if version != "*" and entry.version != version:
                continue
            yield entry

    def list_subvols(self):
        if self.scheme == "file":
            path = self.path or "/var/butterknife/pool/"
            print("Listing local templates in %s" % path)
            for entry in os.listdir(path):
                if entry.startswith("@template:"):
                    yield Template("file://%s/%s" % (path, entry))
        elif self.scheme == "ssh":
            cmd = "ssh", (self.username + "@" if self.username else "") + self.hostname,
            if self.port:
                cmd = cmd + ("-p", self.port)
            cmd += "ls", self.path,
            print("Executing:", " ".join(cmd))
            for entry in subprocess.check_output(cmd).decode("utf-8").split("\n"):
                if entry.startswith("@template:"):
                    url = "ssh://"
                    if self.username:
                        url += self.u.username + "@"
                    url += self.hostname
                    if self.port:
                        url += ":%d" % self.port
                    url += self.path + "/" + entry
                    yield Template(url)
        elif self.scheme in ("http", "https"):
            fh = urllib.request.urlopen("%s://%s/api/template/" % (self.scheme, self.hostname))
            for entry in json.loads(fh.read().decode("ascii"))["templates"]:
                yield "%(namespace)s.%(identifier)s" % entry
        else:
            raise


@click.command(help="Pull templates")
@click.option("--source", required=True, help="Source pool")
@click.option("--destination", default="file://", help="Target pool")
@click.option("-s", "--subvol", default="@template:*.*:*:*", help="Subvolume filter")
def pull(source, destination, subvol):
    click.echo("Pushing %s from %s to %s" % (subvol, source, destination))

    source = Pool(source)
    dest = Pool(destination)

    for n, i, a in set(source.filter_templates(namespace=namespace, identifier=identifier, architecture=architecture)):
        remote_subvols = sorted(source.filter_subvols(namespace=n, identifier=i, architecture=a))
        local_subvols = sorted(dest.filter_subvols(namespace=n, identifier=i, architecture=a))

        click.echo("%d remote subvolumes of %s.%s:%s" % (len(remote_subvols), n,i,a))
        click.echo("%d local subvolumes of %s.%s:%s" % (len(local_subvols), n,i,a))
        
        common_subvols = set(remote_subvols).intersection(set(local_subvols))

        if common_subvols:
            parent_subvol = sorted(common_subvols)[-1]
            click.echo("Last common subvol is: %s" % parent_subvol)
            following_subvols = tuple(filter(lambda subvol: subvol > parent_subvol, remote_subvols))
        else:
            parent_subvol = None
            following_subvols = remote_subvols
            click.echo("No shared subvolumes!")

        if not following_subvols:
            click.echo("All versions of %s.%s:%s synchronized, skipping!" % (n,i,a))
            continue

        for subvol in following_subvols:
            if parent_subvol:
                click.echo("Fetching incremental snapshot %s relative to %s" % (subvol.version, parent_subvol.version))
            else:
                click.echo("Fetching full snapshot %s" % subvol.version)
            btrfs_send = subprocess.Popen(source.command_send(subvol, parent_subvol), stdout=subprocess.PIPE, close_fds=True)
            pv = subprocess.Popen(("pv",), stdin=btrfs_send.stdout, stdout=subprocess.PIPE, close_fds=True)
            btrfs_receive = subprocess.Popen(dest.command_receive(parent_subvol), stdin=pv.stdout, close_fds=True)
            btrfs_receive.communicate()
            parent_subvol = subvol
            click.echo("")

@click.command(help="Push subvolumes")
@click.option("--source", default="file://", help="Source pool")
@click.option("--destination", required=True, help="Destination pool")
@click.option("-c", "--category", default="@template", help="Subvolume type")
@click.option("-n", "--namespace", default="*", help="Template namespace")
@click.option("-i", "--identifier", default="*", help="Template identifier")
@click.option("-a", "--architecture", default="*", help="Architecture")
@click.option("-v", "--version", default="*", help="Version")
def push(source, destination, category, namespace, identifier, architecture, version):
    click.echo("Pushing %s:%s.%s:%s:%s from %s to %s" % (category, namespace,
        identifier, architecture, version, source, destination))

    source = Pool(source)
    dest = Pool(destination)
    raise NotImplementedError()

@click.command(help="List local or remote subvolumes")
@click.option("--pool", default="file:///var/butterknife/pool", help="Remote or local pool")
@click.option("-c", "--category", default="@template", help="Subvolume type")
@click.option("-n", "--namespace", default="*", help="Template namespace")
@click.option("-i", "--identifier", default="*", help="Template identifier")
@click.option("-a", "--architecture", default="*", help="Architecture")
@click.option("-v", "--version", default="*", help="Version")
def list(pool, **kwargs):
    click.echo("Listing %(category)s:%(namespace)s.%(identifier)s:%(architecture)s:%(version)s" % kwargs)
    pool = Pool(pool)
    for template in sorted(pool.filter_subvols(**kwargs)):
        click.echo("%s%s" % (pool, template))
        
        
class Filter(object):
    def __init__(self, pattern="@template:*.*:*:*"):
        self.category, name, self.architecture, self.version = pattern.split(":")
        self.namespace, self.identifier = name.rsplit(".", 1)

    def match(self, subvol):
        try:
            category, name, architecture, version = subvol.split(":")
        except ValueError:
            return False
            
        namespace, identifier = name.rsplit(".", 1)

        if self.category != "*" and self.category != category:
            return False
        if self.namespace != "*" and self.namespace != namespace:
            return False
        if self.identifier != "*" and self.identifier != identifier: # TODO: specify ,
            return False
        if self.architecture != "*" and self.architecture != architecture: # TODO: specify ,
            return False
        if self.version != "*" and self.version != version: # TODO: specify , and  -
            return False
        return True

    def apply(self, iterable):
        for i in iterable:
            if self.match(i):
                yield i
                
    def subset(self, namespace="*", identifier="*", architecture="*", version="*"):
        return Filter(
            "%s:%s.%s:%s:%s" % (
                self.category,
                self.namespace if namespace == "*" else namespace,
                self.identifier if identifier == "*" else identifier,
                self.architecture if architecture == "*" else architecture,
                self.version if version == "*" else version))

@click.command("serve", help="Run built-in HTTP API server")
@click.argument("subvol", default="@template:*.*:*:*")
@click.option("-u", "--user", default="root", help="Run as user")
@click.option("-p", "--port", default=80, help="Listen port")
@click.option("-l", "--listen", default="0.0.0.0", help="Listen address")
def http_serve(match, user, port, listen):
    subvol_filter = Filter(subvol)
 
    pool = LocalPool()

    click.echo("Serving %s from %s at %s:%d" % (subvol, pool, listen, port))
  
    import falcon
    import unicodedata
    import json
    import pwd
    from datetime import date, datetime


    class MyEncoder(json.JSONEncoder):
        def default(self, obj):
            if isinstance(obj, datetime):
                return obj.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + "Z"
            if isinstance(obj, date):
                return obj.strftime('%Y-%m-%d')
            if isinstance(obj, map):
                return tuple(obj)
            if isinstance(obj, Template):
                return obj.version
            return json.JSONEncoder.default(self, obj)

    def serialize(func):
        """
        Falcon response serialization
        """
        def wrapped(instance, req, resp, **kwargs):
            assert not req.get_param("unicode") or req.get_param("unicode") == u"âœ“", "Unicode sanity check failed"
            resp.set_header("Cache-Control", "no-cache, no-store, must-revalidate");
            resp.set_header("Pragma", "no-cache");
            resp.set_header("Expires", "0");
            r = func(instance, req, resp, **kwargs)
            if not resp.body:
                if not req.client_accepts_json:
                    raise falcon.HTTPUnsupportedMediaType(
                        'This API only supports the JSON media type.',
                        href='http://docs.examples.com/api/json')
                resp.set_header('Content-Type', 'application/json')
                resp.body = json.dumps(r, cls=MyEncoder)
            return r
        return wrapped

    class TemplateResource(object):
        @serialize
        def on_get(self, req, resp):
            return {"templates": map(
                lambda j:{"namespace": j[0], "identifier":j[1], "architectures":j[2]},
                pool.template_list(subvol_filter))}

    class VersionResource(object):
        @serialize
        def on_get(self, req, resp, name, arch):
            namespace, identifier = name.rsplit(".", 1)
            return { "versions": map(
                lambda v:{"identifier":v},
                sorted(subvol_filter.apply(pool.subvol_list()), reverse=True, key=lambda j:j.numeric_version)) }

    class StreamingResource(object):
        def on_get(self, req, resp, name, arch, version):

            parent_version = req.get_param("parent")
            
            subvol = "@template:%(name)s:%(arch)s:%(version)s" % locals()
            if subvol_filter.match(subvol): raise
            
            suggested_filename = "%(name)s:%(arch)s:%(version)s" % locals()
            if parent_version:
                parent_subvol = "@template:%(name)s:%(arch)s:%(parent_version)s" % locals()
                if subvol_filter.match(parent_subvol): raise
                suggested_filename += ":" + parent_version
            else:
                parent_subvol = None
            suggested_filename += ".far"

            resp.set_header("Content-Disposition", "attachment; filename=\"%s\"" % suggested_filename)
            resp.set_header('Content-Type', 'application/btrfs-stream')

            streamer = subprocess.Popen(pool.command_send(subvol, parent_subvol), stdout=subprocess.PIPE)
            resp.stream = streamer.stdout

            accepted_encodings = req.get_header("Accept-Encoding") or ""
            accepted_encodings = [j.strip() for j in accepted_encodings.lower().split(",")]

            if "gzip" in accepted_encodings:
                for cmd in "/usr/bin/pigz", "/bin/gzip":
                    if os.path.exists(cmd):
                        resp.set_header('Content-Encoding', 'gzip')
                        print("Compressing with %s" % cmd)
                        compressor = subprocess.Popen((cmd,), stdin=streamer.stdout, stdout=subprocess.PIPE)
                        resp.stream = compressor.stdout
                        break
                else:
                    print("No gzip compressors found, falling back to no compression")
            else:
                print("Client did not ask for compression")

    app = falcon.API()
    app.add_route("/api/template/", TemplateResource())
    app.add_route("/api/template/{name}/arch/{arch}/version/", VersionResource())
    app.add_route("/api/template/{name}/arch/{arch}/version/{version}/stream/", StreamingResource())

    from wsgiref.simple_server import make_server, WSGIServer
    from socketserver import ThreadingMixIn

    class ThreadingWSGIServer(ThreadingMixIn, WSGIServer): 
        pass

    _, _, uid, gid, gecos, root, shell = pwd.getpwnam(user)
    sudoer = os.path.join("/etc/sudoers.d", user)

    if uid == 0:
        print("Warning: running as root, this is not reccommended")
    elif not os.path.exists(sudoer):
        print("Please create %s with following content: %s ALL=(ALL) NOPASSWD: /sbin/btrfs send /var/butterknife/pool/@template:*" % (sudoer, user))

    print("Listening on %s:%d" % (listen, port))
    httpd = make_server(listen, port, app, ThreadingWSGIServer)
    if uid:
        print("Switching to user %s (uid=%d, gid=%d)" % (user, uid, gid))
        os.setgid(gid)
        os.setuid(uid)
    httpd.serve_forever()


@click.command("receive", help="Receive subvolume over multicast")
@click.option("--pool", default="file:///var/butterknife/pool", help="Remote or local pool")
def multicast_receive(pool):
    cmd = "udp-receiver", "--nokbd"
    udpcast = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    pool = Pool(pool)
    btrfs = subprocess.Popen(pool.command_receive(), stdin=udpcast.stdout)
    udpcast.wait()

@click.command("send", help="Send subvolume over multicast")
@click.argument("subvol")
@click.option("--pool", default="file:///var/butterknife/pool", help="Remote or local pool")
@click.option("-m", "--min-wait", default=5, help="Wait until t seconds since first receiver connection has passed")
def multicast_send(subvol, pool, min_wait):
    pool = Pool(pool)
    btrfs = subprocess.Popen(pool.command_send(subvol), stdout=subprocess.PIPE)
    cmd = "udp-sender", "--nokbd", "--no-progress", "--min-receivers", "1", "--min-wait", str(min_wait)
    udpcast = subprocess.Popen(cmd, stdin=btrfs.stdout)
    btrfs.wait()
    
@click.command("release", help="Snapshot a LXC container and release as Butterknife template")
@click.argument("name")
def lxc_release(name):

    config = configparser.ConfigParser()
    config.read('/etc/butterknife/butterknife.conf')
   

    import lxc
    container=lxc.Container(name)
    if container.running:
        print("Stopping container")
        container.stop()

    ROOTFS = container.get_config_item("lxc.rootfs")
    assert os.path.isdir(ROOTFS), "No directory at %s" % ROOTFS

    POSTDEPLOY_SCRIPTS = os.path.join(ROOTFS, "etc", "butterknife", "postdeploy.d")
    assert os.path.isdir(POSTDEPLOY_SCRIPTS), "Postinstall scripts directory %s missing!" % POSTDEPLOY_SCRIPTS

    config.read(os.path.join(ROOTFS, "etc/butterknife/butterknife.conf"))
    if "template" not in config.sections():
        config.add_section("template")
    if "name" not in config["template"]:
        config.set("template", name)
    config.set("template", "endpoint", config.get("global", "endpoint"))
    config.set("template", "namespace", config.get("global", "namespace"))
    
    architecture = container.get_config_item("lxc.arch")
    config.set("template", "architecture", architecture)

    snapshot = container.snapshot()

    config.set("template", "version", snapshot)

    print("Created snapshot:", snapshot)

    snapdir = os.path.join("/var/lib/lxcsnaps", name, snapshot)

    with open(os.path.join(snapdir, "rootfs/etc/butterknife/butterknife.conf"), "w") as fh:
        config.write(fh)

    cmd = "btrfs", "subvolume", "snapshot", "-r", os.path.join(snapdir, "rootfs"), \
        "/var/butterknife/pool/@template:%(namespace)s.%(name)s:%(architecture)s:%(version)s" % config["template"]

    print("Executing:", " ".join(cmd))

    import subprocess
    subprocess.call(cmd)
    
@click.command("list", help="Linux Containers that have been prepared for Butterknife")
def lxc_list():
    import lxc
    for name in lxc.list_containers():
        container=lxc.Container(name)
        rootfs = container.get_config_item("lxc.rootfs")
        
        template_config = os.path.join(rootfs, "etc/butterknife/butterknife.conf")
        if not os.path.exists(template_config):
            continue

        config = configparser.ConfigParser()
        config.read('/etc/butterknife/butterknife.conf')
        config.read(template_config)
        if "template" not in config.sections():
            config.add_section("template")
        if "name" not in config["template"]:
            config.set("template", "name", "?")
        click.echo("%s --> @template:%s:%s:%s" % (name.ljust(40), config.get("global", "namespace"), config.get("template", "name"), container.get_config_item("lxc.arch")))

@click.command("release", help="Release systemd namespace as Butterknife template")
def nspawn_release():
    raise NotImplementedError()
        
@click.command("list", help="systemd namespaces that have been prepared for Butterknife")
def nspawn_list():
    raise NotImplementedError()
    
@click.command(help="Instantiate template (DANGEROUS!)")
def deploy():
    pass
    
@click.group(help="Linux Containers interface")
def lxc(): pass

@click.group(help="systemd-nspawn interface")
def nspawn(): pass

@click.group(help="Receive or serve over multicast")
def multicast(): pass

@click.group(help="Serve HTTP API")
def http(): pass

@click.group()
def cli(): pass

multicast.add_command(multicast_receive)
multicast.add_command(multicast_send)
http.add_command(http_serve)
lxc.add_command(lxc_release)
lxc.add_command(lxc_list)
nspawn.add_command(nspawn_release)
nspawn.add_command(nspawn_list)
cli.add_command(pull)
cli.add_command(push)
cli.add_command(list)
cli.add_command(multicast)
cli.add_command(http)
cli.add_command(lxc)
cli.add_command(nspawn)
cli.add_command(deploy)
if __name__ == "__main__":
    cli()
